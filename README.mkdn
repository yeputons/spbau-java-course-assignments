# 02 - Библиотека "Функциональная Java"

**Дедлайн по тестам**: 2015/09/29 23:59

**Дедлайн по замечаниям**: 2015/10/07 23:59

## Задание

1. Необходимо создать следующие абстрактные классы:

  - `Function1` — функция одного аргумента (`f(x)`)
  - `Function2` — функция от двух аргументов (`f(x,y)`)
  - `Predicate` — предикат для одного аргумента

  Подумайте как лучше применить наследование чтобы выстроить из них иерархию.

2. В рамках этиx абстрактных классов нужно создать:

  - `Function1.compose` — композиция. Принимает `Function1` —  `g` , возвращает `g(f(x))`
  - `Function2.compose` — композиция. Принимает  `Function1` — `g` , возвращает `g(f(x,y))`
  - `Function2.bind1` — bind первого аргумента. Принимает первый аргумент, возвращает `f(_, y)`
  - `Function2.bind2` — bind второго аргумента. Принимает и второй аргумент, возвращает `f(x, _)`
  - `Function2.curry` — [каррирование](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), конвертация в `Functiton1`.
  - `Predicate.or`/`Predicate.and`. Принимают один предикат в качестве аргумента, возвращают предикат, который ведет себя, как дизъюнкция/конъюнкция текущего предиката и предиката-аргумента. Семантика ленивая, как у `||` и `&&`.
  - `Predicate.not` принимает 0 аргументов, возвращает предикат-отрицание текущего предиката
  - Константные статические предикаты: `Predicate.ALWAYS_TRUE`, `Predicate.ALWAYS_FALSE`

3. Cоздать класс `Collections` со следующими статическими методами, оперирующими коллекциями интерфейса `Iterable` и функциями реализованными через вышенаписанные абстрактные классы:
  - `map` — принимает аргумент-функцию `f` и коллекцию `a`, применяет `f` к каждому элементу коллекции `a_i` и возвращает новую коллекцию с элементами `[f(a_1), ..., f(a_n)]`
  - `filter` — принимает предикат `p` и коллекцию `a`, возвращает коллекцию, содержащую элементы `a_i` на которых `p(a_i) == true`
  - `takeWhile` — принимает предикат `p` и коллекцию `a`, возвращает начало коллекции до первого элемента `a_i` для которого `p(a_i) == false` 
  - `takeUnless` — то же, что и `takeWhile`, только для `p(a_i) == true`
  - `foldr` / `foldl` — принимает функцию двух аргументов, начальное значение и коллекцию. Работает [так] (https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0)

4. Покрыть написанный код тестами по максимум. Подробнее о том, как посмотреть coverage написано в README в ветке master. Создавать новые тесты можно на основе примера из первого задания.

## Дополнительно для досдающих

Реализовать следующие функции:

- `Function1.uncurry` - **статическая** функция, обратная `Function2.curry`. Принимает объект `Function1` который возвращает `Function1` и делает из него `Function2`. Пример: 

  ```java
  Function1<?, ?> fn = { ... }; 
  fn.apply(1).apply(2) == Function1.uncurry(fn).apply(1, 2);
  ```
  
- `Function2.flip` - **метод** который меняет местами аргументы объекта `Function2`. Пример:
  
  ```java
  Function2<A, B, C> fn = { ... };
  fn.apply(42, "foo") == fn.flip().apply("foo", 42);
  ```

- `Collection.and` и `Collection.or` - статические функции, которые возвращают результат конъюнкции или дизъюнкции всех элементов в коллекции. Сделайте через уже реализованные функции в классе `Collection`. Пример работы:
  
  ```java
  List<Boolean> trues = Arrays.asList(true, true, true);
  List<Boolean> falses = Arrays.asList(false, false, false);
  List<Boolean> mixed = Arrays.asList(false, true, false);
  Collection.and(trues) == Collection.or(trues) == Collection.or(mixed) == true;
  Collection.and(falses) == Collection.and(mixed) == Collection.or(falses) == false;
  ```
  
- `Collection.concatMap` - статическая функция, которая принимает параметры `Function1<A, Iterable<A>> fn` и `Iterable<A> collection` и возвращает `Collection<A>`. Пример работы:

  ```java
  List<Long> longs = Arrays.asList(1, 2, 3, 4);
  Function2<Long, List<Long>> duplicate = new Function2<>() { 
    public List<Long> apply(Long n) {
      return Arrays.asList(n, n);
    }
  };
  Collection.concatMap(duplicate, longs) == Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4);
  ```

- `Collection.iterate` - статическая функция, которая принимает `Function1<A, A> fn`, `A x` и `int n` и возвращает `Iterable<A>` вида: `[ x, fn(x), fn(fn(x)) ... ]` размера `n`.

- `Collection.zipWith` - статическая функция, которая принимает `Function2<A, B, C> fn`, `Iterable<A> as`, `Iterable<B> bs` и возвращает коллекцию вида `[ fn(a[0], b[0]), fn(a[1], b[1]) ... fn(a[n], b[n]) ]`. Если коллекции неодинаковы по длине, то элементы более длинной отбрасываются и результирующая коллекция имеет длину равную длине меньшей входной коллекции.

## Общие требования

- Сигнатуры классов и методов должны быть одновременно максимально гибкими (наиболее общими), и при этом не должны содержать лишних generic-параметров (т.е. по возможности следует использовать wildcard).

## Полезности

- [Серия статей о дженериках на сайте Oracle](https://docs.oracle.com/javase/tutorial/extra/generics/index.html). Особенно рекомендуется к прочтению [статья про wildcards](https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html) и [про generic methods](https://docs.oracle.com/javase/tutorial/extra/generics/methods.html).
